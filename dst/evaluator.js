// Generated by CoffeeScript 1.4.0
(function() {
  var Evaluator, FormulaVisitor, Unbound, evaluate, funcs, getOperator, unbound,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  FormulaVisitor = require('./visitor');

  Evaluator = (function(_super) {

    __extends(Evaluator, _super);

    function Evaluator(data) {
      this.data = data;
    }

    Evaluator.prototype.visitLiteral = function(node) {
      return node.value;
    };

    Evaluator.prototype.visitReference = function(node) {
      return this.data[node.name];
    };

    Evaluator.prototype.visitInfixExpression = function(node) {
      return Evaluator.__super__.visitInfixExpression.call(this, node, getOperator(node.operator));
    };

    Evaluator.prototype.visitFunctionCall = function(node) {
      var func, param, vals;
      vals = (function() {
        var _i, _len, _ref, _results;
        _ref = node.parameters;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          param = _ref[_i];
          _results.push(param.visit(this));
        }
        return _results;
      }).call(this);
      func = funcs[node.name];
      if (func != null) {
        return func(vals);
      } else {
        return this.data["" + node.name + "()"];
      }
    };

    return Evaluator;

  })(FormulaVisitor);

  getOperator = function(operator) {
    switch (operator) {
      case '+':
        return function(a, b) {
          return a + b;
        };
      case '-':
        return function(a, b) {
          return a - b;
        };
      case '*':
        return function(a, b) {
          return a * b;
        };
      case '/':
        return function(a, b) {
          return a / b;
        };
      case '^':
        return function(a, b) {
          return Math.pow(a, b);
        };
      case '&':
        return function(a, b) {
          return a + b;
        };
      case '&&':
        return function(a, b) {
          return a && b;
        };
      case '||':
        return function(a, b) {
          return a || b;
        };
      case '=':
      case '==':
        return function(left, right) {
          return left === right;
        };
      case '!=':
      case '<>':
        return function(left, right) {
          return left !== right;
        };
      case '<':
        return function(left, right) {
          return left < right;
        };
      case '>':
        return function(left, right) {
          return left > right;
        };
      case '<=':
        return function(left, right) {
          return left <= right;
        };
      case '>=':
        return function(left, right) {
          return left >= right;
        };
    }
  };

  funcs = {
    'and': function(p) {
      return p.reduce(function(a, b) {
        return a && b;
      });
    },
    'or': function(p) {
      return p.reduce(function(a, b) {
        return a || b;
      });
    },
    'not': function(p) {
      return !p[0];
    },
    'if': function(p) {
      if (p[0]) {
        return p[1];
      } else {
        return p[2];
      }
    },
    'case': function(p) {
      var elseIndex, i, _i;
      elseIndex = p.length - 1;
      for (i = _i = 1; 1 <= elseIndex ? _i < elseIndex : _i > elseIndex; i = 1 <= elseIndex ? ++_i : --_i) {
        if (i % 2 === 1) {
          if (p[i] === p[0]) {
            return p[i + 1];
          }
        }
      }
      return p[elseIndex];
    },
    'ispickval': function(p) {
      return p[0] === p[1];
    },
    'isnumber': function(p) {
      return p[0] === '' + parseFloat(p[0]);
    },
    'isnull': function(p) {
      return !(p[0] != null);
    },
    'isblank': function(p) {
      return !(p[0] != null) || p[0] === '';
    },
    'nullvalue': function(p) {
      if (p[0] != null) {
        return p[0];
      } else {
        return p[1];
      }
    },
    'blankvalue': function(p) {
      if ((p[0] != null) && p[0] !== '') {
        return p[0];
      } else {
        return p[1];
      }
    },
    'abs': function(p) {
      return Math.abs(p[0]);
    },
    'ceiling': function(p) {
      return Math.ceil(p[0]);
    },
    'exp': function(p) {
      return Math.exp(p[0]);
    },
    'floor': function(p) {
      return Math.floor(p[0]);
    },
    'ln': function(p) {
      return Math.log(p[0]);
    },
    'max': function(p) {
      return Math.max.apply(null, p);
    },
    'min': function(p) {
      return Math.min.apply(null, p);
    },
    'mod': function(p) {
      return p[0] % p[1];
    },
    'round': function(p) {
      return Math.round(p[0]);
    },
    'sqrt': function(p) {
      return Math.sqrt(p[0]);
    },
    'begins': function(p) {
      return p[0].startsWith(p[1]);
    },
    'br': function(p) {
      return '\n';
    },
    'find': function(p) {
      return p[1].indexOf(p[0]);
    },
    'hyperlink': function(p) {
      return "<a href='" + p[0] + "'>" + p[1] + "</a>";
    },
    'left': function(p) {
      return p[0].substr(0, p[1]);
    },
    'len': function(p) {
      return p[0].length;
    },
    'lower': function(p) {
      return p[0].toLowerCase();
    },
    'mid': function(p) {
      return p[0].substr(p[1], p[2]);
    },
    'text': function(p) {
      return '' + p[0];
    },
    'trim': function(p) {
      return p[0].trim();
    },
    'right': function(p) {
      return p[0].substr(-p[1]);
    },
    'replace': function(p) {
      return p[0].replace(p[1], p[2]);
    },
    'upper': function(p) {
      return p[0].toUpperCase();
    },
    'urlencode': function(p) {
      return encodeURI(p[0]);
    },
    'value': function(p) {
      return parseFloat(p[0]);
    }
  };

  Unbound = (function(_super) {

    __extends(Unbound, _super);

    function Unbound() {
      return Unbound.__super__.constructor.apply(this, arguments);
    }

    Unbound.prototype.visitLiteral = function() {
      return [];
    };

    Unbound.prototype.visitInfixExpression = function(node) {
      return Unbound.__super__.visitInfixExpression.call(this, node, function(left, right) {
        var ref, refs, _i, _j, _len, _len1;
        refs = [];
        for (_i = 0, _len = left.length; _i < _len; _i++) {
          ref = left[_i];
          if (-1 === refs.indexOf(ref)) {
            refs.push(ref);
          }
        }
        for (_j = 0, _len1 = right.length; _j < _len1; _j++) {
          ref = right[_j];
          if (-1 === refs.indexOf(ref)) {
            refs.push(ref);
          }
        }
        return refs;
      });
    };

    Unbound.prototype.visitReference = function(node) {
      return [node.name];
    };

    Unbound.prototype.visitFunctionCall = function(node) {
      var func, param, ref, refs, _i, _j, _len, _len1, _ref, _ref1;
      refs = [];
      _ref = node.parameters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _ref1 = param.visit(this);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ref = _ref1[_j];
          if (-1 === refs.indexOf(ref)) {
            refs.push(ref);
          }
        }
      }
      func = node.name + '()';
      if (!(funcs[node.name] != null) && -1 === refs.indexOf(func)) {
        refs.push(func);
      }
      return refs;
    };

    return Unbound;

  })(FormulaVisitor);

  evaluate = function(f, data) {
    return f.visit(new Evaluator(data));
  };

  unbound = function(f) {
    return f.visit(new Unbound);
  };

  module.exports = {
    evaluate: evaluate,
    unbound: unbound
  };

}).call(this);
