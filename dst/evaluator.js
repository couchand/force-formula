// Generated by CoffeeScript 1.4.0
(function() {
  var Addition, Comparator, Comparison, Concatenation, Conjunction, DecimalLiteral, Disjunction, Division, Factory, FunctionCall, InfixExpression, IntegerLiteral, Multiplication, Parens, Reference, StringLiteral, Subtraction, build, evaluate, factory, funcs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Factory = (function() {

    function Factory() {}

    Factory.prototype.build = function(node) {
      var Builder;
      switch (node.expression) {
        case 'add':
          Builder = Addition;
          break;
        case 'subtract':
          Builder = Subtraction;
          break;
        case 'multiply':
          Builder = Multiplication;
          break;
        case 'divide':
          Builder = Division;
          break;
        case 'concat':
          Builder = Concatenation;
          break;
        case 'conjunction':
          Builder = Conjunction;
          break;
        case 'disjunction':
          Builder = Disjunction;
          break;
        case 'comparison':
          Builder = Comparison;
          break;
        case 'parens':
          Builder = Parens;
          break;
        case 'string':
          Builder = StringLiteral;
          break;
        case 'decimal':
          Builder = DecimalLiteral;
          break;
        case 'integer':
          Builder = IntegerLiteral;
          break;
        case 'reference':
          Builder = Reference;
          break;
        case 'function':
          Builder = FunctionCall;
          break;
        default:
          throw 'unknown node type';
      }
      return new Builder(node);
    };

    return Factory;

  })();

  factory = new Factory();

  InfixExpression = (function() {

    function InfixExpression(node, operator) {
      this.operator = operator;
      this.left = factory.build(node.left);
      this.right = factory.build(node.right);
    }

    InfixExpression.prototype.evaluate = function(data) {
      return this.operator(this.left.evaluate(data), this.right.evaluate(data));
    };

    InfixExpression.prototype.unbound = function() {
      var ref, refs, _i, _j, _len, _len1, _ref, _ref1;
      refs = [];
      _ref = this.left.unbound();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ref = _ref[_i];
        if (-1 === refs.indexOf(ref)) {
          refs.push(ref);
        }
      }
      _ref1 = this.right.unbound();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ref = _ref1[_j];
        if (-1 === refs.indexOf(ref)) {
          refs.push(ref);
        }
      }
      return refs;
    };

    return InfixExpression;

  })();

  Addition = (function(_super) {

    __extends(Addition, _super);

    function Addition(node) {
      Addition.__super__.constructor.call(this, node, function(left, right) {
        return left + right;
      });
    }

    return Addition;

  })(InfixExpression);

  Subtraction = (function(_super) {

    __extends(Subtraction, _super);

    function Subtraction(node) {
      Subtraction.__super__.constructor.call(this, node, function(left, right) {
        return left - right;
      });
    }

    return Subtraction;

  })(InfixExpression);

  Multiplication = (function(_super) {

    __extends(Multiplication, _super);

    function Multiplication(node) {
      Multiplication.__super__.constructor.call(this, node, function(left, right) {
        return left * right;
      });
    }

    return Multiplication;

  })(InfixExpression);

  Division = (function(_super) {

    __extends(Division, _super);

    function Division(node) {
      Division.__super__.constructor.call(this, node, function(left, right) {
        return left / right;
      });
    }

    return Division;

  })(InfixExpression);

  Concatenation = (function(_super) {

    __extends(Concatenation, _super);

    function Concatenation(node) {
      Concatenation.__super__.constructor.call(this, node, function(left, right) {
        return left + right;
      });
    }

    return Concatenation;

  })(InfixExpression);

  Conjunction = (function(_super) {

    __extends(Conjunction, _super);

    function Conjunction(node) {
      Conjunction.__super__.constructor.call(this, node, function(left, right) {
        return left && right;
      });
    }

    return Conjunction;

  })(InfixExpression);

  Disjunction = (function(_super) {

    __extends(Disjunction, _super);

    function Disjunction(node) {
      Disjunction.__super__.constructor.call(this, node, function(left, right) {
        return left || right;
      });
    }

    return Disjunction;

  })(InfixExpression);

  Comparison = (function(_super) {

    __extends(Comparison, _super);

    function Comparison(node) {
      Comparison.__super__.constructor.call(this, node);
      this.comparator = new Comparator(node.comparator);
    }

    Comparison.prototype.evaluate = function(data) {
      return this.comparator.compare(this.left.evaluate(data), this.right.evaluate(data));
    };

    return Comparison;

  })(InfixExpression);

  Comparator = (function() {

    function Comparator(comparator) {
      this.comparator = comparator;
    }

    Comparator.prototype.compare = function(left, right) {
      switch (this.comparator) {
        case '=':
        case '==':
          return left === right;
        case '!=':
        case '<>':
          return left !== right;
        case '<':
          return left < right;
        case '>':
          return left > right;
        case '<=':
          return left <= right;
        case '>=':
          return left >= right;
      }
    };

    return Comparator;

  })();

  Parens = (function() {

    function Parens(node) {
      this.formula = factory.build(node.formula);
    }

    Parens.prototype.evaluate = function(data) {
      return this.formula.evaluate(data);
    };

    Parens.prototype.unbound = function() {
      return this.formula.unbound();
    };

    return Parens;

  })();

  StringLiteral = (function() {

    function StringLiteral(node) {
      this.value = node.string;
    }

    StringLiteral.prototype.evaluate = function(data) {
      return this.value;
    };

    StringLiteral.prototype.unbound = function() {
      return [];
    };

    return StringLiteral;

  })();

  DecimalLiteral = (function() {

    function DecimalLiteral(node) {
      this.value = parseFloat(node.whole + '.' + node.part);
    }

    DecimalLiteral.prototype.evaluate = function(data) {
      return this.value;
    };

    DecimalLiteral.prototype.unbound = function() {
      return [];
    };

    return DecimalLiteral;

  })();

  IntegerLiteral = (function() {

    function IntegerLiteral(node) {
      this.value = parseInt(node.value);
    }

    IntegerLiteral.prototype.evaluate = function(data) {
      return this.value;
    };

    IntegerLiteral.prototype.unbound = function() {
      return [];
    };

    return IntegerLiteral;

  })();

  Reference = (function() {

    function Reference(node) {
      this.name = node.name.join('.');
    }

    Reference.prototype.evaluate = function(data) {
      return data[this.name];
    };

    Reference.prototype.unbound = function() {
      return [this.name];
    };

    return Reference;

  })();

  FunctionCall = (function() {

    function FunctionCall(node) {
      var param;
      this.params = (function() {
        var _i, _len, _ref, _results;
        _ref = node.parameters;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          param = _ref[_i];
          _results.push(factory.build(param));
        }
        return _results;
      })();
      this.name = node["function"].toLowerCase();
      this.func = funcs[this.name];
    }

    FunctionCall.prototype.evaluate = function(data) {
      var param, vals;
      vals = (function() {
        var _i, _len, _ref, _results;
        _ref = this.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          param = _ref[_i];
          _results.push(param.evaluate(data));
        }
        return _results;
      }).call(this);
      return this.func(vals);
    };

    FunctionCall.prototype.unbound = function() {
      var func, param, ref, refs, _i, _j, _len, _len1, _ref, _ref1;
      refs = [];
      _ref = this.params;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _ref1 = param.unbound();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ref = _ref1[_j];
          if (-1 === refs.indexOf(ref)) {
            refs.push(ref);
          }
        }
      }
      func = this.name + '()';
      if (!(this.func != null) && -1 === refs.indexOf(func)) {
        refs.push(func);
      }
      return refs;
    };

    return FunctionCall;

  })();

  funcs = {
    'and': function(p) {
      return p.reduce(function(a, b) {
        return a && b;
      });
    },
    'or': function(p) {
      return p.reduce(function(a, b) {
        return a || b;
      });
    },
    'not': function(p) {
      return !p[0];
    },
    'if': function(p) {
      if (p[0]) {
        return p[1];
      } else {
        return p[2];
      }
    },
    'case': function(p) {
      var elseIndex, i, _i;
      elseIndex = p.length - 1;
      for (i = _i = 1; 1 <= elseIndex ? _i < elseIndex : _i > elseIndex; i = 1 <= elseIndex ? ++_i : --_i) {
        if (i % 2 === 1) {
          if (p[i] === p[0]) {
            return p[i + 1];
          }
        }
      }
      return p[elseIndex];
    },
    'ispickval': function(p) {
      return p[0] === p[1];
    },
    'isnumber': function(p) {
      return p[0] === '' + parseFloat(p[0]);
    },
    'isnull': function(p) {
      return !(p[0] != null);
    },
    'isblank': function(p) {
      return !(p[0] != null) || p[0] === '';
    },
    'nullvalue': function(p) {
      if (p[0] != null) {
        return p[0];
      } else {
        return p[1];
      }
    },
    'blankvalue': function(p) {
      if ((p[0] != null) && p[0] !== '') {
        return p[0];
      } else {
        return p[1];
      }
    },
    'abs': function(p) {
      return Math.abs(p[0]);
    },
    'ceiling': function(p) {
      return Math.ceil(p[0]);
    },
    'exp': function(p) {
      return Math.exp(p[0]);
    },
    'floor': function(p) {
      return Math.floor(p[0]);
    },
    'ln': function(p) {
      return Math.log(p[0]);
    },
    'max': function(p) {
      return Math.max.apply(null, p);
    },
    'min': function(p) {
      return Math.min.apply(null, p);
    },
    'mod': function(p) {
      return p[0] % p[1];
    },
    'round': function(p) {
      return Math.round(p[0]);
    },
    'sqrt': function(p) {
      return Math.sqrt(p[0]);
    },
    'begins': function(p) {
      return p[0].startsWith(p[1]);
    },
    'br': function(p) {
      return '\n';
    },
    'find': function(p) {
      return p[1].indexOf(p[0]);
    },
    'hyperlink': function(p) {
      return "<a href='" + p[0] + "'>" + p[1] + "</a>";
    },
    'left': function(p) {
      return p[0].substr(0, p[1]);
    },
    'len': function(p) {
      return p[0].length;
    },
    'lower': function(p) {
      return p[0].toLowerCase();
    },
    'mid': function(p) {
      return p[0].substr(p[1], p[2]);
    },
    'text': function(p) {
      return '' + p[0];
    },
    'trim': function(p) {
      return p[0].trim();
    },
    'right': function(p) {
      return p[0].substr(-p[1]);
    },
    'replace': function(p) {
      return p[0].replace(p[1], p[2]);
    },
    'upper': function(p) {
      return p[0].toUpperCase();
    },
    'urlencode': function(p) {
      return encodeURI(p[0]);
    },
    'value': function(p) {
      return parseFloat(p[0]);
    }
  };

  evaluate = function(formula, data) {
    var f;
    f = factory.build(formula);
    return f.evaluate(data);
  };

  build = function(formula) {
    return factory.build(formula);
  };

  module.exports = {
    evaluate: evaluate,
    build: build
  };

}).call(this);
